#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <linux/fb.h>
#include <stdarg.h>
#include <string.h>

// 8x8 font bitmap (ASCII 32-127)
static const uint8_t font8x8[96][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x18,0x3c,0x3c,0x18,0x18,0x00,0x18,0x00}, // space, !
    {0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00}, {0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,0x6c,0x00}, // ", #
    {0x18,0x3e,0x60,0x3c,0x06,0x7c,0x18,0x00}, {0x00,0xc6,0xcc,0x18,0x30,0x66,0xc6,0x00}, // $, %
    {0x38,0x6c,0x38,0x76,0xdc,0xcc,0x76,0x00}, {0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00}, // &, '
    {0x0c,0x18,0x30,0x30,0x30,0x18,0x0c,0x00}, {0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x00}, // (, )
    {0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00}, {0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00}, // *, +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, {0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00}, // ,, -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, {0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00}, // ., /
    {0x7c,0xc6,0xce,0xde,0xf6,0xe6,0x7c,0x00}, {0x30,0x70,0x30,0x30,0x30,0x30,0xfc,0x00}, // 0, 1
    {0x78,0xcc,0x0c,0x38,0x60,0xcc,0xfc,0x00}, {0x78,0xcc,0x0c,0x38,0x0c,0xcc,0x78,0x00}, // 2, 3
    {0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x1e,0x00}, {0xfc,0xc0,0xf8,0x0c,0x0c,0xcc,0x78,0x00}, // 4, 5
    {0x38,0x60,0xc0,0xf8,0xcc,0xcc,0x78,0x00}, {0xfc,0xcc,0x0c,0x18,0x30,0x30,0x30,0x00}, // 6, 7
    {0x78,0xcc,0xcc,0x78,0xcc,0xcc,0x78,0x00}, {0x78,0xcc,0xcc,0x7c,0x0c,0x18,0x70,0x00}, // 8, 9
    {0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00}, {0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x00}, // :, ;
    {0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x00}, {0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00}, // <, =
    {0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00}, {0x78,0xcc,0x0c,0x18,0x30,0x00,0x18,0x00}, // >, ?
    {0x7c,0xc6,0xde,0xde,0xde,0xc0,0x78,0x00}, {0x30,0x78,0xcc,0xcc,0xfc,0xcc,0xcc,0x00}, // @, A
    {0xfc,0x66,0x66,0x7c,0x66,0x66,0xfc,0x00}, {0x3c,0x66,0xc0,0xc0,0xc0,0x66,0x3c,0x00}, // B, C
    {0xf8,0x6c,0x66,0x66,0x66,0x6c,0xf8,0x00}, {0xfe,0x62,0x68,0x78,0x68,0x62,0xfe,0x00}, // D, E
    {0xfe,0x62,0x68,0x78,0x68,0x60,0xf0,0x00}, {0x3c,0x66,0xc0,0xc0,0xce,0x66,0x3e,0x00}, // F, G
    {0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0x00}, {0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00}, // H, I
    {0x1e,0x0c,0x0c,0x0c,0xcc,0xcc,0x78,0x00}, {0xe6,0x66,0x6c,0x78,0x6c,0x66,0xe6,0x00}, // J, K
    {0xf0,0x60,0x60,0x60,0x60,0x62,0xfe,0x00}, {0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0x00}, // L, M
    {0xc6,0xe6,0xf6,0xde,0xce,0xc6,0xc6,0x00}, {0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00}, // N, O
    {0xfc,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00}, {0x7c,0xc6,0xc6,0xc6,0xda,0xcc,0x76,0x00}, // P, Q
    {0xfc,0x66,0x66,0x7c,0x6c,0x66,0xe6,0x00}, {0x78,0xcc,0xe0,0x70,0x1c,0xcc,0x78,0x00}, // R, S
    {0xfc,0xb4,0x30,0x30,0x30,0x30,0x78,0x00}, {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x00}, // T, U
    {0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00}, {0xc6,0xc6,0xc6,0xd6,0xfe,0xee,0xc6,0x00}, // V, W
    {0xc6,0xc6,0x6c,0x38,0x6c,0xc6,0xc6,0x00}, {0xcc,0xcc,0xcc,0x78,0x30,0x30,0x78,0x00}, // X, Y
    {0xfe,0xc6,0x8c,0x18,0x32,0x66,0xfe,0x00}, {0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00}, // Z, [
    {0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00}, {0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00}, // \, ]
    {0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00}, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff}, // ^, _
};

struct fb_var_screeninfo vinfo;
uint16_t *fbp = NULL;
int cursor_x = 10, cursor_y = 10;
FILE *log_file = NULL;

// Draw a single 8x8 character to the framebuffer
void draw_char(int x, int y, char c, uint16_t color) {
    if (c < 32 || c > 127) return;
    const uint8_t *bitmap = font8x8[c - 32];
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if (bitmap[i] & (1 << (7 - j))) {
                int px = x + j;
                int py = y + i;
                if (px >= 0 && px < vinfo.xres && py >= 0 && py < vinfo.yres) {
                    fbp[py * vinfo.xres + px] = color;
                }
            }
        }
    }
}

// Custom printf that outputs to BOTH the screen and the /mnt/sdcard/info.txt file
void screen_printf(const char *format, ...) {
    char buffer[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    // Save to file
    if (log_file) {
        fprintf(log_file, "%s", buffer);
        fflush(log_file);
    }
    
    // Output to framebuffer with basic wrapping
    for (int i = 0; buffer[i] != '\0'; i++) {
        if (buffer[i] == '\n') {
            cursor_x = 10;
            cursor_y += 10;
        } else {
            draw_char(cursor_x, cursor_y, buffer[i], 0xFFFF); // White
            cursor_x += 8;
            // Screen wrap logic
            if (cursor_x > (int)vinfo.xres - 10) {
                cursor_x = 10;
                cursor_y += 10;
            }
        }
        // Basic screen scroll reset (if we hit the bottom, restart at top)
        if (cursor_y > (int)vinfo.yres - 10) {
            cursor_y = 10;
        }
    }
}

// Helper to dump file contents to screen and log
void dump_sys_file(const char *title, const char *path, int max_lines) {
    screen_printf(">> %s [%s]\n", title, path);
    FILE *f = fopen(path, "r");
    if (!f) {
        screen_printf("   Error: File not found.\n");
        return;
    }
    char line[256];
    int count = 0;
    while (fgets(line, sizeof(line), f) && count < max_lines) {
        screen_printf(" %s", line);
        count++;
    }
    fclose(f);
    screen_printf("\n");
}

int main() {
    // 1. Setup Log File
    log_file = fopen("/mnt/sdcard/info.txt", "w");
    
    // 2. Setup Framebuffer
    int fbfd = open("/dev/fb0", O_RDWR);
    if (fbfd == -1) {
        printf("Error: Cannot open /dev/fb0\n");
        if (log_file) fclose(log_file);
        return 1;
    }

    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo)) {
        printf("Error reading screen info\n");
        close(fbfd);
        return 1;
    }

    long screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    fbp = (uint16_t *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);
    if (fbp == MAP_FAILED) {
        printf("Error: failed to mmap framebuffer\n");
        close(fbfd);
        return 1;
    }

    // Clear Screen
    for (int i = 0; i < vinfo.xres * vinfo.yres; i++) fbp[i] = 0x0000;

    screen_printf("MIPS BLACKBOX SYSTEM PROBE\n");
    screen_printf("==========================\n");

    // --- SYSTEM INFO PROBES ---
    dump_sys_file("KERNEL", "/proc/version", 1);
    dump_sys_file("BOOT ARGS", "/proc/cmdline", 2);
    dump_sys_file("CPU INFO", "/proc/cpuinfo", 6);
    dump_sys_file("MEMORY", "/proc/meminfo", 4);
    dump_sys_file("PARTITIONS", "/proc/partitions", 8);
    dump_sys_file("MOUNTS", "/proc/mounts", 10);

    // Current Working Directory
    char cwd[256];
    if (getcwd(cwd, sizeof(cwd))) {
        screen_printf(">> PWD: %s\n\n", cwd);
    }

    // List Root Directory using popen
    screen_printf(">> ROOT CONTENTS (/)\n");
    FILE *ls_fp = popen("ls -F /", "r");
    if (ls_fp) {
        char buf[256];
        while (fgets(buf, sizeof(buf), ls_fp)) {
            screen_printf(" %s", buf);
        }
        pclose(ls_fp);
    }

    // framebuffer debug commands
    system("ls -l /dev/fb* > /mnt/sdcard/fb_list.txt");
    system("cat /sys/class/graphics/fb0/modes >> /mnt/sdcard/fb_list.txt");
    system("fbset -i >> /mnt/sdcard/fb_list.txt");
    system("dmesg > /mnt/sdcard/dmesg.txt");
    system("whoami > /mnt/sdcard/extra.txt");
    system("uname -a >> /mnt/sdcard/extra.txt");
    system("df -h >> /mnt/sdcard/extra.txt");
    system("ls -l / >> /mnt/sdcard/extra.txt");

    screen_printf("\nDiagnostic Complete.\nSaved to /mnt/sdcard/info.txt\nExiting in 10s...");

    // Final Sync to ensure data is physically written to flash/SD
    if (log_file) {
        fflush(log_file);
        fsync(fileno(log_file));
    }
    sync();
    sleep(10);

    // Cleanup
    munmap(fbp, screensize);
    close(fbfd);
    if (log_file) fclose(log_file);

    return 0;
}
