#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <linux/fb.h>
#include <stdarg.h>
#include <string.h>
#include <dirent.h>

#define MARGIN 60  // Safe area to prevent text cutoff on TVs

// 8x8 font bitmap (ASCII 32-127)
static const uint8_t font8x8[96][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x18,0x3c,0x3c,0x18,0x18,0x00,0x18,0x00}, // space, !
    {0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00}, {0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,0x6c,0x00}, // ", #
    {0x18,0x3e,0x60,0x3c,0x06,0x7c,0x18,0x00}, {0x00,0xc6,0xcc,0x18,0x30,0x66,0xc6,0x00}, // $, %
    {0x38,0x6c,0x38,0x76,0xdc,0xcc,0x76,0x00}, {0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00}, // &, '
    {0x0c,0x18,0x30,0x30,0x30,0x18,0x0c,0x00}, {0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x00}, // (, )
    {0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00}, {0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00}, // *, +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, {0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00}, // ,, -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, {0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00}, // ., /
    {0x7c,0xc6,0xce,0xde,0xf6,0xe6,0x7c,0x00}, {0x30,0x70,0x30,0x30,0x30,0x30,0xfc,0x00}, // 0, 1
    {0x78,0xcc,0x0c,0x38,0x60,0xcc,0xfc,0x00}, {0x78,0xcc,0x0c,0x38,0x0c,0xcc,0x78,0x00}, // 2, 3
    {0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x1e,0x00}, {0xfc,0xc0,0xf8,0x0c,0x0c,0xcc,0x78,0x00}, // 4, 5
    {0x38,0x60,0xc0,0xf8,0xcc,0xcc,0x78,0x00}, {0xfc,0xcc,0x0c,0x18,0x30,0x30,0x30,0x00}, // 6, 7
    {0x78,0xcc,0xcc,0x78,0xcc,0xcc,0x78,0x00}, {0x78,0xcc,0xcc,0x7c,0x0c,0x18,0x70,0x00}, // 8, 9
    {0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00}, {0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x00}, // :, ;
    {0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x00}, {0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00}, // <, =
    {0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00}, {0x78,0xcc,0x0c,0x18,0x30,0x00,0x18,0x00}, // >, ?
    {0x7c,0xc6,0xde,0xde,0xde,0xc0,0x78,0x00}, {0x30,0x78,0xcc,0xcc,0xfc,0xcc,0xcc,0x00}, // @, A
    {0xfc,0x66,0x66,0x7c,0x66,0x66,0xfc,0x00}, {0x3c,0x66,0xc0,0xc0,0xc0,0x66,0x3c,0x00}, // B, C
    {0xf8,0x6c,0x66,0x66,0x66,0x6c,0xf8,0x00}, {0xfe,0x62,0x68,0x78,0x68,0x62,0xfe,0x00}, // D, E
    {0xfe,0x62,0x68,0x78,0x68,0x60,0xf0,0x00}, {0x3c,0x66,0xc0,0xc0,0xce,0x66,0x3e,0x00}, // F, G
    {0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0x00}, {0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00}, // H, I
    {0x1e,0x0c,0x0c,0x0c,0xcc,0xcc,0x78,0x00}, {0xe6,0x66,0x6c,0x78,0x6c,0x66,0xe6,0x00}, // J, K
    {0xf0,0x60,0x60,0x60,0x60,0x62,0xfe,0x00}, {0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0x00}, // L, M
    {0xc6,0xe6,0xf6,0xde,0xce,0xc6,0xc6,0x00}, {0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00}, // N, O
    {0xfc,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00}, {0x7c,0xc6,0xc6,0xc6,0xda,0xcc,0x76,0x00}, // P, Q
    {0xfc,0x66,0x66,0x7c,0x6c,0x66,0xe6,0x00}, {0x78,0xcc,0xe0,0x70,0x1c,0xcc,0x78,0x00}, // R, S
    {0xfc,0xb4,0x30,0x30,0x30,0x30,0x78,0x00}, {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x00}, // T, U
    {0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00}, {0xc6,0xc6,0xc6,0xd6,0xfe,0xee,0xc6,0x00}, // V, W
    {0xc6,0xc6,0x6c,0x38,0x6c,0xc6,0xc6,0x00}, {0xcc,0xcc,0xcc,0x78,0x30,0x30,0x78,0x00}, // X, Y
    {0xfe,0xc6,0x8c,0x18,0x32,0x66,0xfe,0x00}, {0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00}, // Z, [
    {0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00}, {0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00}, // \, ]
    {0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00}, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff}, // ^, _
};

struct fb_var_screeninfo vinfo;
uint32_t *fbp32 = NULL;
int cursor_x = MARGIN, cursor_y = MARGIN;
FILE *log_file = NULL;

void mkdir_p(const char *path) {
    char tmp[1024];
    snprintf(tmp, sizeof(tmp), "%s", path);
    for (char *p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = 0;
            if (strlen(tmp) > 0) mkdir(tmp, S_IRWXU);
            *p = '/';
        }
    }
    mkdir(path, S_IRWXU);
}

void copy_file(const char *src, const char *dst) {
    FILE *fsrc = fopen(src, "rb");
    if (!fsrc) return;
    FILE *fdst = fopen(dst, "wb");
    if (!fdst) { fclose(fsrc); return; }
    char buffer[4096];
    size_t n;
    while ((n = fread(buffer, 1, sizeof(buffer), fsrc)) > 0) fwrite(buffer, 1, n, fdst);
    fclose(fsrc);
    fclose(fdst);
}

void copy_dir(const char *src_dir, const char *dst_dir) {
    DIR *dir = opendir(src_dir);
    if (!dir) return;
    mkdir_p(dst_dir);
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        char s_path[1024], d_path[1024];
        snprintf(s_path, sizeof(s_path), "%s/%s", src_dir, entry->d_name);
        snprintf(d_path, sizeof(d_path), "%s/%s", dst_dir, entry->d_name);
        struct stat st;
        if (lstat(s_path, &st) == 0 && S_ISDIR(st.st_mode)) copy_dir(s_path, d_path);
        else copy_file(s_path, d_path);
    }
    closedir(dir);
}

void draw_char_large(int x, int y, char c, uint32_t color) {
    if (c < 32 || c > 127) return;
    const uint8_t *bitmap = font8x8[c - 32];
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if (bitmap[i] & (1 << (7 - j))) {
                for(int dy=0; dy<2; dy++) {
                    for(int dx=0; dx<2; dx++) {
                        int px = x + (j * 2) + dx;
                        int py = y + (i * 2) + dy;
                        if (px >= 0 && px < (int)vinfo.xres && py >= 0 && py < (int)vinfo.yres) {
                            fbp32[py * vinfo.xres + px] = color;
                        }
                    }
                }
            }
        }
    }
}

void screen_printf(const char *format, ...) {
    char buffer[4096];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    if (log_file) { fprintf(log_file, "%s", buffer); fflush(log_file); }
    
    for (int i = 0; buffer[i] != '\0'; i++) {
        if (buffer[i] == '\n') {
            cursor_x = MARGIN; cursor_y += 20;
        } else {
            draw_char_large(cursor_x, cursor_y, buffer[i], 0xFFFFFFFF);
            cursor_x += 16;
            if (cursor_x > (int)vinfo.xres - MARGIN) { cursor_x = MARGIN; cursor_y += 20; }
        }
        if (cursor_y > (int)vinfo.yres - MARGIN) {
            // Clear screen and reset within margins
            for (int p = 0; p < (int)(vinfo.xres * vinfo.yres); p++) fbp32[p] = 0x00000000;
            // Redraw border
            for (int x=0; x<vinfo.xres; x++) { fbp32[x] = 0xFFFF0000; fbp32[(vinfo.yres-1)*vinfo.xres + x] = 0xFFFF0000; }
            for (int y=0; y<vinfo.yres; y++) { fbp32[y*vinfo.xres] = 0xFFFF0000; fbp32[y*vinfo.xres + (vinfo.xres-1)] = 0xFFFF0000; }
            cursor_y = MARGIN;
        }
    }
}

void run_cmd(const char* cmd) {
    screen_printf("\n========================================\n  %s\n========================================\n", cmd);
    FILE *fp = popen(cmd, "r");
    if (fp) {
        char buf[256];
        while (fgets(buf, sizeof(buf), fp)) screen_printf("%s", buf);
        pclose(fp);
    }
}

void dump_sys_file(const char* path) {
    screen_printf("\n========================================\n  %s\n========================================\n", path);
    FILE *f = fopen(path, "r");
    if (!f) { screen_printf("Error: Could not open %s\n", path); return; }
    char line[256];
    while (fgets(line, sizeof(line), f)) screen_printf("%s", line);
    fclose(f);
}

int main() {
    log_file = fopen("/mnt/sdcard/RK_GAME_DIAG.txt", "w");
    if (!log_file) log_file = fopen("/mnt/info.txt", "w");

    int fbfd = open("/dev/fb0", O_RDWR);
    if (fbfd == -1) return 1;

    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo)) {
        vinfo.xres = 1280; vinfo.yres = 720; vinfo.bits_per_pixel = 32;
    }
    vinfo.bits_per_pixel = 32;

    long screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    fbp32 = (uint32_t *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);

    // Initial Screen Clear
    for (int i = 0; i < (int)(vinfo.xres * vinfo.yres); i++) fbp32[i] = 0x00000000;

    // Draw visible Red Border (1px) to check for TV Overscan
    for (int x=0; x<vinfo.xres; x++) { fbp32[x] = 0xFFFF0000; fbp32[(vinfo.yres-1)*vinfo.xres + x] = 0xFFFF0000; }
    for (int y=0; y<vinfo.yres; y++) { fbp32[y*vinfo.xres] = 0xFFFF0000; fbp32[y*vinfo.xres + (vinfo.xres-1)] = 0xFFFF0000; }

    screen_printf("RK-GAME MIPS DIAGNOSTIC REPORT\n");

    // 1. Live Info
    run_cmd("uname -a");
    run_cmd("df -h");
    run_cmd("mount");
    run_cmd("ls -l /");
    run_cmd("ps w");
    run_cmd("ls /etc/");
    
    // 2. Snapshot Folders
    screen_printf("\nBacking up /etc/ ...\n");
    copy_dir("/etc/", "/mnt/sdcard/diag_dump/etc");
    
    screen_printf("Backing up /proc/device-tree/ ...\n");
    copy_dir("/proc/device-tree", "/mnt/sdcard/diag_dump/device-tree");

    screen_printf("Backing up /proc/1/ metadata ...\n");
    mkdir_p("/mnt/sdcard/diag_dump/pid1");
    copy_file("/proc/1/cmdline", "/mnt/sdcard/diag_dump/pid1/cmdline");
    copy_file("/proc/1/environ", "/mnt/sdcard/diag_dump/pid1/environ");
    copy_file("/proc/1/status", "/mnt/sdcard/diag_dump/pid1/status");

    // 3. Proc Dumps
    dump_sys_file("/proc/cmdline");
    dump_sys_file("/proc/partitions");
    dump_sys_file("/proc/version");
    dump_sys_file("/proc/cpuinfo");
    dump_sys_file("/proc/mounts");
    run_cmd("dmesg > /mnt/sdcard/dmesg.txt");

    // 4. Framebuffer info
    dump_sys_file("/sys/class/graphics/fb0/modes");

    screen_printf("\nDIAGNOSTICS COMPLETE. FILE SAVED TO SD CARD.\n");
    
    if (log_file) { fsync(fileno(log_file)); fclose(log_file); }
    sync();
    sleep(15);

    munmap(fbp32, screensize);
    close(fbfd);
    return 0;
}
